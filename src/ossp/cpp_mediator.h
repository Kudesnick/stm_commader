/***************************************************************************************************
 *   Project:       
 *   Author:        
 ***************************************************************************************************
 *   Distribution:  
 *
 ***************************************************************************************************
 *   MCU Family:    STM32F
 *   Compiler:      ARMCC
 ***************************************************************************************************
 *   File:          cpp_mediator.h
 *   Description:   Модуль, обеспечивающий взаимодействие между элементами системы посредством
 *                  типизированных очередей.
 * 
 *
 ***************************************************************************************************
 *   History:       27.05.2019 - file created
 *
 **************************************************************************************************/

#pragma once

/***************************************************************************************************
 *                                      INCLUDED FILES
 **************************************************************************************************/

#include <stdlib.h>
#include <stdint.h>
#include "cpp_list.h"
#include "cpp_os.h"

#ifdef __cplusplus
    using namespace std;
#endif

/***************************************************************************************************
 *                                       DEFINITIONS
 **************************************************************************************************/

/***************************************************************************************************
 *                                      PUBLIC TYPES
 **************************************************************************************************/

//-- сообщение

// Шаблонный класс элемента "сообшение". Класс обеспечивает хранение элемента определенного типа и
// передачу его всем подписчикам при попытке изменить его значение.
template<typename T> class message_t
{
private:
    T val_;

    static void notify(message_t & _id, const T _val);

public:

    // Чтение значения параметра
    const T &val = val_;

    // Чтение значения параметра через метод
    T get(void)
    {
        return val_;
    };
    
    // Запись нового значения и оповещение подписчиков
    void set(const T _val)
    {
        val_ = _val;

        notify(*this, val_);
    };

    // Запись нового сообщения и оповещение подписчиков в случае, если новое значение отличается
    // от предыдущего
    void set_if_neq(const T _val)
    {
        if (memcmp(&val_, &_val, sizeof(T)) != 0)
        {
            set(_val);
        }
    };

    // Оповещение всех подписчиков. При этом сохраненное значение не изменяется
    void cmd(const T _val)
    {
        notify(*this, _val);
    };

    // Изменение сохраненного значения без оповещения подписчиков
    void set_shadow(const T _val)
    {
        val_ = _val;
    };
};

//-- запись элемента в очередь

// Шаблонный класс обертки сообщения для отправки через очередь. Добавляется поле id, фактически - 
// указатель на объект, сгенерировавший рассылку
template<typename T> struct queue_message_t
{
    message_t<T> * id;
    T val;
};

//-- очередь с подпиской на события определенного типа

// Шаблонный класс очереди "подписчика"
/* Параметризация шаблона:
 * - T - тип элементов "сообщение" на которые подписана очередь
 * - T_queue_count - количество элементов в очереди
 */
template <typename T> class subscriber_base : public cpp_list<subscriber_base<T>>
{
protected:
    friend class message_t<T>;

    virtual osMessageQueueId_t get_id(void) = 0;

    static void notify(message_t<T> & _id, const T _val)
    {
        queue_message_t<T> msg;
        msg.id = &_id;
        msg.val = _val;

        cpp_list<subscriber_base<T>>::enumerate(&msg, [](subscriber_base<T> *& _el, void * _msg)
        {
            osMessageQueuePut(_el->get_id(), _msg, NULL, 0);
        
            return true;
        });
    };

public:
    using cpp_list<subscriber_base<T>>::cpp_list;
};

template<typename T, uint32_t T_queue_count = 4> class subscriber_queue :
    public subscriber_base<T>, 
    public cpp_os_queue<queue_message_t<T>, T_queue_count>
{
protected:
    osMessageQueueId_t get_id(void) 
    {
        return cpp_os_queue<queue_message_t<T>, T_queue_count>::id_;
    };

public:
    using subscriber_base<T>::subscriber_base;
    using cpp_os_queue<queue_message_t<T>, T_queue_count>::cpp_os_queue;
};

template<typename T> void message_t<T>::notify(message_t<T> & _id, const T _val)
{
    subscriber_base<T>::notify(_id, _val);
};

/***************************************************************************************************
 *                                PUBLIC FUNCTION PROTOTYPES
 **************************************************************************************************/

/***************************************************************************************************
 *                               PUBLIC CLASS
 **************************************************************************************************/

/***************************************************************************************************
 *                                     GLOBAL VARIABLES
 **************************************************************************************************/

/***************************************************************************************************
 *                                       END OF FILE
 **************************************************************************************************/
